<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读《民主·宪法·人权》有感]]></title>
    <url>%2F2018%2F08%2F02%2F%E8%AF%BB%E3%80%8A%E6%B0%91%E4%B8%BB%C2%B7%E5%AE%AA%E6%B3%95%C2%B7%E4%BA%BA%E6%9D%83%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[读书读书。。。。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>费孝通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 派发机制]]></title>
    <url>%2F2018%2F05%2F22%2FSwift-%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[此篇博客用来自我学习，来源戴铭大佬的这篇博客 Swift 派发机制派发目的是让 CPU 知道被调用的函数在哪里。Swift 语言是支持编译型语言的直接派发，函数表派发和消息机制派发三种派发方式的，下面分别对这三种派发方式说明下。 直接派发C++ 默认使用的是直接派发，加上 virtual修饰符可以改成函数表派发。直接派发是最快的，原因是调用指令会少，还可以通过编译器进行比如内联等方式的优化。缺点是由于缺少动态性而不支持继承。 12345678910struct DragonFirePosition &#123;var x:Int64var y:Int32func land() &#123;&#125;&#125;func DragonWillFire(_ position:DragonFirePosition) &#123;position.land()&#125;let position = DragonFirePosition(x: 342, y: 213)DragonWillFire(position) 编译 inline 后 DragonWillFire(DragonFirePosition(x: 342, y: 213))会直接跳到方法实现的地方，结果就变成 position.land()。 函数表派发Java 默认就是使用的函数表派发，通过 final 修饰符改成直接派发。函数表派发是有动态性的，在 Swift 里函数表叫 witness table，大部分语言叫 virtual table。一个类里会用数组来存储里面的函数指针，override 父类的函数会替代以前的函数，子类添加的函数会被加到这个数组里。举个例子： 123456789101112class Fish &#123;func swim() &#123;&#125;func eat() &#123;//normal eat&#125;&#125;class FlyingFish: Fish &#123;override func eat() &#123;//flying fish eat&#125;func fly() &#123;&#125;&#125; 编译器会给 Fish 类和 FlyingFish 类分别创建 witness table。在 Fish 的函数表里有 swim 和 eat 函数，在 FlyingFish 函数表里有父类 Fish 的 swim，覆盖了父类的 eat 和新增加的函数 fly。 一个函数被调用时会先去读取对象的函数表，再根据类的地址加上该的函数的偏移量得到函数地址，然后跳到那个地址上去。从编译后的字节码这方面来看就是两次读取一次跳转，比直接派发还是慢了些。 消息机制派发这种机制是在运行时可以改变函数的行为，KVO 和 CoreData 都是这种机制的运用。OC 默认就是使用的消息机制派发，使用 C 来直接派发获取高性能。Swift 可以通过 dynamic 修饰来支持消息机制派发。 当一个消息被派发，运行时就会按照继承关系向上查找被调用的函数。但是这样效率不高，所以需要通过缓存来提高效率，这样查找性能就能和函数派发差不多了。 具体派发声明值类型都会采用直接派发。无论是 class 还是协议 的 extension 也都是直接派发。class 和协议是函数表派发。 指定派发方式 final：让类里的函数使用直接派发，这样该函数将会没有动态性，运行时也没法取到这个函数。 dynamic：可以让类里的函数使用消息机制派发，可以让 extension 里的函数被 override。 派发优化Swift 会在这上面做优化，比如一个函数没有 override，Swift 就可能会使用直接派发的方式，所以如果属性绑定了 KVO 它的 getter和 setter 方法可能会被优化成直接派发而导致 KVO 的失效，所以记得加上 dynamic 的修饰来保证有效。后面 Swift 应该会在这个优化上去做更多的处理。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Runtime的理解]]></title>
    <url>%2F2018%2F04%2F13%2FiOS-Runtime%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1字数5000+,预计阅读时间 30分钟 主要参考自: iOS运行时(Runtime)详解+Demo Objective-C Runtime 神经病院Objective-C Runtime出院第三天——如何正确使用Runtime 运行时简介Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。Runtime基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。在Runtime中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，让OC的面向对象编程变为可能。找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，Runtime会根据消息接收者是否能响应该消息而做出不同的反应。 一、类与对象基础数据结构1、object_class 类Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。1typedef struct object_class *Class 它的定义如下：1234567891011121314struct object_class&#123;Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list *methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表#endif&#125;OBJC2_UNAVAILABLE; 2、objc_object 实例objc_object是表示一个类的实例的结构体它的定义如下：1234struct objc_object&#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;typedef struct objc_object *id; 可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法，找到后即运行这个方法。 3、元类(Meta Class)meta-class是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么，这个isa指针指向什么呢？ 答案是，为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，meta-class中存储着一个类的所有类方法。 所以，调用类方法的这个类对象的isa指针指向的就是meta-class当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。 再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。 即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。 通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下： 4、CategoryCategory是表示一个指向分类的结构体的指针，其定义如下：12345678typedef struct objc_category *Categorystruct objc_category&#123; char *category_name OBJC2_UNAVAILABLE; // 分类名 char *class_name OBJC2_UNAVAILABLE; // 分类所属的类名 struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表 struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 分类所实现的协议列表&#125; 这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。可发现，类别中没有ivar成员变量指针，也就意味着：类别中不能够添加实例变量和属性,(!除非使用关联对象,而且Category中的属性，只会生成setter和getter方法，不会生成成员变量)例子如下1234567891011121314151617181920#import &quot;UIButton+ClickBlock.h&quot;#import static const void *associatedKey = &quot;associatedKey&quot;;@implementation UIButton (ClickBlock)//Category中的属性，只会生成setter和getter方法，不会生成成员变量-(void)setClick:(clickBlock)click&#123; objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC); [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside]; if (click) &#123; [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside]; &#125;&#125;-(clickBlock)click&#123; return objc_getAssociatedObject(self, associatedKey);&#125;-(void)buttonClick&#123; if (self.click) &#123; self.click(); &#125;&#125;@end 然后在代码中，就可以使用 UIButton 的属性来监听单击事件了：123456UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];button.frame = self.view.bounds;[self.view addSubview:button];button.click = ^&#123;NSLog(@&quot;buttonClicked&quot;);&#125;; 关联对象的使用1234567891.设置关联值参数说明：object：与谁关联，通常是传selfkey：唯一键，在获取值时通过该键获取，通常是使用staticconst void *来声明value：关联所设置的值policy：内存管理策略，比如使用copyvoid objc_setAssociatedObject(id object, const void *key, id value, objc _AssociationPolicy policy) 123452.获取关联值参数说明：object：与谁关联，通常是传self，在设置关联时所指定的与哪个对象关联的那个对象key：唯一键，在设置关联时所指定的键id objc_getAssociatedObject(id object, const void *key) 123.取消关联void objc_removeAssociatedObjects(id object) 1234567891011关联策略使用场景：可以在类别中添加属性typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123; OBJC_ASSOCIATION_ASSIGN = 0, // 表示弱引用关联，通常是基本数据类型 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 表示强引用关联对象，是线程安全的 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 表示关联对象copy，是线程安全的 OBJC_ASSOCIATION_RETAIN = 01401, // 表示强引用关联对象，不是线程安全的 OBJC_ASSOCIATION_COPY = 01403 // 表示关联对象copy，不是线程安全的&#125;; 二、方法与消息1、SEL SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：1typedef struct objc_selector *SEL； 方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。两个类之间，只要方法名相同，那么方法的SEL就是一样的，每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行如在某一个类中定义以下两个方法: 错误 12- (void)setWidth:(int)width;- (void)setWidth:(double)width; 当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。工程中的所有的SEL组成一个Set集合，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。1234通过下面三种方法可以获取SEL:a、sel_registerName函数b、Objective-C编译器提供的@selector()c、NSSelectorFromString()方法 2、IMP IMP实际上是一个函数指针，指向方法实现的地址。其定义如下:1id (*IMP)(id, SEL,...) 第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)第二个参数：是方法选择器(selector)接下来的参数：方法的参数列表。 前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。 3、Method Method用于表示类定义中的方法，则定义如下： 123456typedef struct objc_method *Methodstruct objc_method&#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; 我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。 4、消息 Objc 中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。 有关消息发送和消息转发机制的原理，可以查看这篇文章。 面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为：1objc_msgSend(receiver, selector) 如果消息含有参数，则为：1objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。 现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送 message这条消息，而 receiver 将要如何响应这条消息，那就要看运行时发生的情况来决定了。 这里看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：12345671、检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。2、检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。3、如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。4、如果 cache 找不到就找一下方法分发表。5、如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。6、如果还找不到就要开始进入动态方法解析了，后面会提到。PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。 其实编译器会根据情况在objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或 objc_msgSendSuper_stret四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有”stret”的函数。排列组合正好四个方法。 值得一提的是在i386 平台处理返回类型为浮点数的消息时，需要用到objc_msgSend_fpret函数来进行处理，这是因为返回类型为浮点数的函数对应的ABI(Application Binary Interface)与返回整型的函数的ABI不兼容。此时objc_msgSend不再适用，于是objc_msgSend_fpret被派上用场，它会对浮点数寄存器做特殊处理。不过在PPC 或 PPC64 平台是不需要麻烦它的。 PS：有木有发现这些函数的命名规律哦？带“Super”的是消息传递给超类；“stret”可分为“st”+“ret”两部分，分别代表“struct”和“return”；“fpret”就是“fp”+“ret”，分别代表“floating-point”和“return”。 5、动态方法解析 你可以动态地提供一个方法的实现。例如我们可以用@dynamic关键字在类的实现文件中修饰一个属性：1@dynamic propertyName; 这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成setPropertyName:和propertyName方法，而需要我们动态提供。我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法实现和类方法实现。因为当Runtime系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作：123456789101112void dynamicMethodIMP(id self, SEL _cmd) &#123;// implementation ....&#125;@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:aSEL];&#125;@end 上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 Type Encoding PS：动态方法解析会在消息转发机制浸入前执行。如果 respondsToSelector: 或 instancesRespondToSelector:方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的IMP的机会。如果你想让该方法选择器被传送到转发机制，那么就让resolveInstanceMethod:返回NO。 备注: 解析类方法等具体做法 例：.h123456#import &lt;Foundation/Foundation.h&gt;@interface Student : NSObject+ (void)learnClass:(NSString *) string;- (void)goToSchool:(NSString *) name;@end .m1234567891011121314151617181920212223242526272829#import &quot;Student.h&quot;#import &lt;objc/runtime.h&gt;@implementation Student+ (BOOL)resolveClassMethod:(SEL)sel &#123; if (sel == @selector(learnClass:)) &#123; class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(myClassMethod:)), &quot;v@:&quot;); return YES; &#125; return [class_getSuperclass(self) resolveClassMethod:sel];&#125;+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(goToSchool:)) &#123; class_addMethod([self class], aSEL, class_getMethodImplementation([self class], @selector(myInstanceMethod:)), &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:aSEL];&#125;+ (void)myClassMethod:(NSString *)string &#123; NSLog(@&quot;myClassMethod = %@&quot;, string);&#125;- (void)myInstanceMethod:(NSString *)string &#123; NSLog(@&quot;myInstanceMethod = %@&quot;, string);&#125;@end 需要深刻理解[self class] 与 object_getClass(self) 甚至 object_getClass([self class]) 的关系，其实并不难，重点在于 self 的类型： 123451、当 self 为实例对象时，[self class] 与 object_getClass(self) 等价，因为前者会调用后者。object_getClass([self class]) 得到元类。2、当 self 为类对象时，[self class] 返回值为自身，还是 self。object_getClass(self) 与 object_getClass([self class]) 等价。 6、消息转发 重定向 在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载- (id)forwardingTargetForSelector:(SEL)aSelector方法替换消息的接受者为其他对象：123456- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(mysteriousMethod:))&#123; return alternateObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，如果此方法返回nil或self,则会进入消息转发机制(forwardInvocation:);否则将向返回的对象重新发送消息。 如果想替换类方法的接受者，需要覆写 + (id)forwardingTargetForSelector:(SEL)aSelector方法，并返回类对象：123456+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if(aSelector == @selector(xxx)) &#123; return NSClassFromString(@&quot;Class name&quot;); &#125; return [super forwardingTargetForSelector:aSelector];&#125; 转发 当动态方法解析不作处理返回NO时，消息转发机制会被触发。在这时forwardInvocation:方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：12345678- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; if ([someOtherObject respondsToSelector:[anInvocation selector]])&#123; [anInvocation invokeWithTarget:someOtherObject]; &#125;else&#123; [super forwardInvocation:anInvocation]; &#125;&#125; 该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。 这里需要注意的是参数anInvocation是从哪的来的呢？其实在forwardInvocation:消息发送前，Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。所以我们在重写forwardInvocation:的同时也要重写methodSignatureForSelector:方法，否则会抛异常。 当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过forwardInvocation:消息通知该对象。每个对象都从NSObject类中继承了forwardInvocation:方法。然而，NSObject中的方法实现只是简单地调用了doesNotRecognizeSelector:。通过实现我们自己的forwardInvocation:方法，我们可以在该方法实现中将消息转发给其它对象。 forwardInvocation:方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。 注意： forwardInvocation:方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将negotiate消息转发给其它对象，则这个对象不能有negotiate方法。否则，forwardInvocation:将不可能会被调用。 转发与多继承 转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。 这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中Warrior和Diplomat没有继承关系，但是Warrior将negotiate消息转发给了Diplomat后，就好似Diplomat是Warrior的超类一样。 消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。 转发与继承 尽管转发很像继承，但是NSObject类不会将两者混淆。像respondsToSelector:和 isKindOfClass:这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个Warrior对象如果被问到是否能响应negotiate消息：12if ( [aWarrior respondsToSelector:@selector(negotiate)] )... 结果是NO，尽管它能够接受negotiate消息而不报错，因为它靠转发消息给Diplomat类来响应消息。 如果你为了某些意图偏要“弄虚作假”让别人以为Warrior继承到了Diplomat的negotiate方法，你得重新实现 respondsToSelector:和 isKindOfClass:来加入你的转发算法：1234567891011- (BOOL)respondsToSelector:(SEL)aSelector&#123; if ( [super respondsToSelector:aSelector] )&#123; return YES; &#125;else &#123;/* Here, test whether the aSelector message can ** be forwarded to another object and whether that ** object can respond to it. Return YES if it can. */ &#125; return NO;&#125; 除了respondsToSelector: 和isKindOfClass:之外，instancesRespondToSelector:中也应该写一份转发算法。如果使用了协议，conformsToProtocol:同样也要加入到这一行列中。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个methodSignatureForSelector:来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现methodSignatureForSelector:：1234567- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector&#123; NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; signature = [surrogate methodSignatureForSelector:selector]; &#125; return signature;&#125; 7、方法交换 Method Swizzling 之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。 123456Swizzling原理在Objective-C中调用一个方法，其实是向一个对象发送消息，而查找消息的唯一依据是selector的名字。所以，我们可以利用Objective-C的runtime机制，实现在运行时交换selector对应的方法实现以达到我们的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现 这是参考Mattt大神在NSHipster上的文章自己写的代码。1234567891011121314151617181920212223242526272829303132333435#import &lt;objc/runtime.h&gt; @implementation UIViewController (Tracking) + (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class aClass = [self class]; // When swizzling a class method, use the following: // Class aClass = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(aClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(aClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;); &#125; #pragma mark - Method Swizzling - (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@&quot;viewWillAppear: %@&quot;, self); &#125; @end 上面的代码通过添加一个Tracking类别到UIViewController类中，将UIViewController类的viewWillAppear:方法和Tracking类别中xxx_viewWillAppear:方法的实现相互调换。Swizzling 应该在+load方法中实现，因为+load是在一个类最开始加载时调用。dispatch_once是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。 如果类中不存在要替换的方法，那就先用class_addMethod和class_replaceMethod函数添加和替换两个方法的实现；如果类中已经有了想要替换的方法，那么就调用method_exchangeImplementations函数交换了两个方法的 IMP，这是苹果提供给我们用于实现Method Swizzling的便捷方法。 可能有人注意到了这行:12345// When swizzling a class method, use the following:// Class aClass = object_getClass((id)self);// ...// Method originalMethod = class_getClassMethod(aClass, originalSelector);// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector); object_getClass((id)self) 与 [self class]返回的结果类型都是 Class,但前者为元类,后者为其本身,因为此时 self 为 Class 而不是实例.注意 [NSObject class] 与 [object class] 的区别：1234567+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125; PS: 如果类中没有想被替换实现的原方法时，class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现；否则调用method_setImplementation方法，types参数会被忽略。method_exchangeImplementations方法做的事情与如下的原子操作等价：1234IMP imp1 = method_getImplementation(m1);IMP imp2 = method_getImplementation(m2);method_setImplementation(m1, imp2);method_setImplementation(m2, imp1); 最后xxx_viewWillAppear:方法的定义看似是递归调用引发死循环，其实不会的。因为[self xxx_viewWillAppear:animated]消息会动态找到xxx_viewWillAppear:方法的实现，而它的实现已经被我们与viewWillAppear:方法实现进行了互换，所以这段代码不仅不会死循环，如果你把[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]反而会引发死循环。PS: 看到有人说+load方法本身就是线程安全的，因为它在程序刚开始就被调用，很少会碰到并发问题，于是 stackoverflow 上也有大神去掉了dispatch_once 部分。 扩展阅读:1、iOS—防止UIButton重复点击的三种实现方式2、Swift Runtime分析：还像OC Runtime一样吗？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化APP启动时间实践 iOS]]></title>
    <url>%2F2018%2F04%2F12%2F%E4%BC%98%E5%8C%96APP%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%AE%9E%E8%B7%B5-iOS%2F</url>
    <content type="text"><![CDATA[前言当用户按下home键的时候，iOS的App并不会马上被kill掉，还会继续存活若干时间。理想情况下，用户点击App的图标再次回来的时候，App几乎不需要做什么，就可以还原到退出前的状态，继续为用户服务。这种持续存活的情况下启动App，我们称为热启动，相对而言冷启动就是App被kill掉以后一切从头开始启动的过程。我们这里只讨论App冷启动的情况。 对于冷启动来说，启动时间是指从用户点击 APP 那一刻开始到用户看到第一个界面这中间的时间。我们进行优化的时候，我们将启动时间分为 pre-main 时间和 main 函数到第一个界面渲染完成时间这两个部分。因为 APP 的入口在 main 函数 ，在 main 函数之后我们的代码才会执行。 这里有两个阶段12345678910111213141516171. pre-main阶段1.1. 加载应用的可执行文件1.2. 加载动态链接库加载器dyld（dynamic loader）1.3. dyld递归加载应用所有依赖的dylib（dynamic library 动态链接库）2. main()阶段2.1. dyld调用main() 2.2. 调用UIApplicationMain() 2.3. 调用applicationWillFinishLaunching2.4. 调用didFinishLaunchingWithOptions 我们把 pre-main阶段称为 t1，main()阶段一直到首个页面加载完成称为 t2。 t1 时间的优化分析t1部分主要参考自APP启动优化的一次实践 其中 t1苹果提供了内建的测量方法, Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS 设为 11234567891011121314//结果为Total pre-main time: 1.4 seconds (100.0%)dylib loading time: 1.3 seconds (89.4%)rebase/binding time: 36.75 milliseconds (2.5%)ObjC setup time: 35.65 milliseconds (2.4%)initializer time: 80.97 milliseconds (5.5%)slowest intializers :libSystem.B.dylib : 12.63 milliseconds (0.8%)//解读1、main()函数之前总共使用了1.4s2、在94.33ms中，加载动态库用了1.3s，指针重定位使用了36.75ms，ObjC类初始化使用了35.65ms，各种初始化使用了80.97ms。3、在初始化耗费的80.97ms中，用时最多的初始化是libSystem.B.dylib。 可以看到,我的 dylib loading time 花费了 1.3s时间， 其中各部分的作用是1234加载dylib分析每个dylib（大部分是iOS系统的），找到其Mach-O文件，打开并读取验证有效性，找到代码签名注册到内核，最后对dylib的每个segment调用mmap()。 1234567rebase/binddylib加载完成之后，它们处于相互独立的状态，需要绑定起来。在dylib的加载过程中，系统为了安全考虑，引入了ASLR（Address Space Layout Randomization）技术和代码签名。由于ASLR的存在，镜像（Image，包括可执行文件、dylib和bundle）会在随机的地址上加载，和之前指针指向的地址（preferred_address）会有一个偏差（slide），dyld需要修正这个偏差，来指向正确的地址。Rebase在前，Bind在后，Rebase做的是将镜像读入内存，修正镜像内部的指针，性能消耗主要在IO。Bind做的是查询符号表，设置指向镜像外部的指针，性能消耗主要在CPU计算。 1234567OC setupOC的runtime需要维护一张类名与类的方法列表的全局表。dyld做了如下操作：对所有声明过的OC类，将其注册到这个全局表中（class registration）将category的方法插入到类的方法列表中（category registration）检查每个selector的唯一性（selector uniquing） 1如果在各个 OC 类别的 ‘load’方法里做了不少事情(如在里面使用 Method swizzle),那么会耗时不少。dyld运行APP的初始化函数，调用每个OC类的+load方法，调用C++的构造器函数（attribute((constructor))修饰），创建非基本类型的C++静态全局变量，然后执行main函数。 优化思路是12341. 移除不需要用到的动态库2. 移除不需要用到的类3. 合并功能类似的类和扩展4. 尽量避免在+load方法里执行的操作，可以推迟到+initialize方法中。 t2 时间的优化分析t2使用了来自NewPan大大 的打点计时器BLStopwatch 可以看到，我的 APP 加载时间并没有很慢，但是也想看一看有没有优化的空间。 在 didFinishLaunchingWithOptions 方法里我们一般都有以下的逻辑：1234初始化第三方 SDK配置 APP 运行需要的环境自己的一些工具类的初始化... 这里主要参考[iOS]一次立竿见影的启动时间优化从优化图可以看到，我的应用的跳转逻辑是 打开 -&gt; 广告页 -&gt; 首页，首页的UI 架构是: 但是如果 UI 架构如上，并且在didFinishLaunchingWithOptions里面设置了根视图123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;NSLog(@"didFinishLaunchingWithOptions 开始执行");self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];TestTabBarController *tabBarVc = [TestTabBarController new];self.window.rootViewController = tabBarVc;[self.window makeKeyAndVisible];NSLog(@"didFinishLaunchingWithOptions 跑完了");return YES;&#125; 然后我们来到 TestTabBarController 里的 viewDidLoad方法里进行它的 viewControllers 的设置，然后再进入到每个 viewController 的 viewDidLoad 方法里进行更多的初始化操作。那么你觉得从 didFinishLaunchingWithOptions 到最后显示展示的 viewController 的 viewDidLoad 这些方法的执行顺序是怎么样的呢？1234didFinishLaunchingWithOptions 开始执行 开始加载 TestTabBarController 的 viewDidLoaddidFinishLaunchingWithOptions 跑完了开始加载 TestViewController 的 viewDidLoad, 然后执行一堆初始化的操作 在TestTabBarController 中操作了 TestViewController 的 view 的话，那么调用顺序将会是这样：1234didFinishLaunchingWithOptions 开始执行 开始加载 TestTabBarController 的 viewDidLoad开始加载 TestViewController 的 viewDidLoad, 然后执行一堆初始化的操作didFinishLaunchingWithOptions 跑完了 这样的问题就是当我们把界面的初始化、网络请求、数据解析、视图渲染等操作放在了viewDidLoad 方法里，这样一来每次启动 APP 的时候，在用户看到第一个页面之前，我们要把这些事件全部都处理完，才会进入到视图渲染阶段。 一般来说，我们放到didFinishLaunchingWithOptions执行的代码，有很多初始化操作，如日志，统计，SDK配置等。尽量做到只放必需的，其他的可以延迟到MainViewController展示完成viewDidAppear以后。123* 日志、统计等必须在 APP 一启动就最先配置的事件* 项目配置、环境配置、用户信息的初始化 、推送、IM等事件* 其他 SDK 和配置事件 第一类，必须第一时间启动，仍然把它留在 didFinishLaunchingWithOptions 里启动。 第二类，这些功能在用户进入 APP 主体的之前是必须要加载完的，我把他放到广告页面的viewDidAppear启动。 第三类，由于启动时间不是必须的，所以我们可以放在第一个界面的 viewDidAppear 方法里，这里完全不会影响到启动时间。 这是优化后的启动时间 优化思路1234567891011梳理各个三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法里。梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。避免复杂/多余的计算。避免在首页控制器的viewDidLoad和viewWillAppear做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。采用性能更好的API。首页控制器用纯代码方式来构建。 另：[iOS]一次立竿见影的启动时间优化 提到了使用一个工具类来管理的方法，可以比较方便的管理优化。 总结性价比最高的优化阶段就是t2的一些逻辑整理，尽量将不需要的耗时操作延迟到首屏展示之后执行。同时一般来说，优化应该在项目完成稳定之后进行，避免过早优化. 参考： App Startup Time: Past, Present, and Future [iOS]一次立竿见影的启动时间优化 iOS App 启动性能优化) APP启动优化的一次实践 阿里数据iOS端启动速度优化的一些经验]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift与JavaScript的交互(通过JavaScriptCore)]]></title>
    <url>%2F2018%2F02%2F27%2FSwift%E4%B8%8EJavaScript%E7%9A%84%E4%BA%A4%E4%BA%92-%E9%80%9A%E8%BF%87JavaScriptCore%2F</url>
    <content type="text"><![CDATA[前言此篇参考自iOS开发 - Swift使用JavaScriptCore与JS交互作者 ：天秤vs永恒1实践通过 JavaScriotCore 来实现 Swift 和 JS 的交互。 一、JavaScriptCore中的类1234JSContext：JSContext是JS的执行环境，通过evaluateScript()方法可以执行JS代码JSValue： JSValue封装了JS与ObjC中的对应的类型，以及调用JS的API等JSExport： JSExport是一个协议，遵守此协议，就可以定义我们自己的协议，在协议中声明的API都会在JS中暴露出来，这样JS才能调用原生的API 二、在 Swift 中调用 JS 有两种方法。1、直接通过 JSContext 执行 JS 代码。12345678910111213141516171819import JavaScriptCore //记得导入JavaScriptCorelet context: JSContext = JSContext()let result1: JSValue = context.evaluateScript("1 + 3")print(result1) // 输出4// 定义js变量和函数context.evaluateScript("var num1 = 10; var num2 = 20;")context.evaluateScript("function multiply(param1, param2) &#123; return param1 * param2; &#125;")// 通过js方法名调用方法let result2 = context.evaluateScript("multiply(num1, num2)")print(result2 ?? "result2 = nil") // 输出200// 通过下标来获取js方法并调用方法let squareFunc = context.objectForKeyedSubscript("multiply")let result3 = squareFunc?.call(withArguments: [10, 20]).toString()print(result3 ?? "result3 = nil") // 输出200 2、 在Swift中通过JSContext注入模型，然后调用模型的方法 首先定义一个协议SwiftJavaScriptDelegate 该协议必须遵守JSExport协议 12345678910111213141516// 定义协议SwiftJavaScriptDelegate 该协议必须遵守JSExport协议@objc protocol SwiftJavaScriptDelegate: JSExport &#123;// js调用App的返回方法func popVC()// js调用App的showDic。传递Dict 参数func showDic(_ dict: [String: AnyObject])// js调用App方法时传递多个参数 并弹出对话框 注意js调用时的函数名func showDialog(_ title: String, message: String)// js调用App的功能后 App再调用js函数执行回调func callHandler(_ handleFuncName: String)&#125; 然后定义一个模型 该模型实现SwiftJavaScriptDelegate协议(这里注意，如果有更改 UI 的需求，那么需要回到主线程。因为调用不在主线程) 12345678910111213141516171819202122232425262728293031323334353637// 定义一个模型 该模型实现SwiftJavaScriptDelegate协议@objc class SwiftJavaScriptModel: NSObject, SwiftJavaScriptDelegate &#123;weak var controller: UIViewController?weak var jsContext: JSContext?func popVC() &#123;if let vc = controller &#123;DispatchQueue.main.async &#123;vc.navigationController?.popViewController(animated: true)&#125;&#125;&#125;func showDic(_ dict: [String: AnyObject]) &#123;print("展示信息：", dict,"= = ")// 调起微信分享逻辑&#125;func showDialog(_ title: String, message: String) &#123;let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)alert.addAction(UIAlertAction(title: "确定", style: .default, handler: nil))self.controller?.present(alert, animated: true, completion: nil)&#125;func callHandler(_ handleFuncName: String) &#123;let jsHandlerFunc = self.jsContext?.objectForKeyedSubscript("\(handleFuncName)")let dict = ["name": "sean", "age": 18] as [String : Any]let _ = jsHandlerFunc?.call(withArguments: [dict])&#125;&#125; 然后使用WebView加载对应的网页，这里加载例子中的demo.html文件 123456789101112131415func setWebView()&#123;webView = UIWebView(frame: self.view.bounds)view.addSubview(webView)webView.delegate = selfwebView.scalesPageToFit = true// 测试加载本地Html页面let url = Bundle.main.url(forResource: "demo", withExtension: "html")let request = URLRequest(url: url!)// 加载网络Html页面 请设置允许Http请求// let url = URL(string: "https://www.jianshu.com/u/50bd017bb4ba")// let request = URLRequest(url: url!)webView.loadRequest(request)&#125; 在webViewDidFinishLoad代理中将我们定义的模型注入到网页中，暴露给JS 12345678910111213141516171819202122232425func webViewDidFinishLoad(_ webView: UIWebView) &#123;setContext()&#125;func setContext()&#123;let context = webView.value(forKeyPath: "documentView.webView.mainFrame.javaScriptContext") as! JSContextlet model = SwiftJavaScriptModel()model.controller = selfmodel.jsContext = context// 这一步是将SwiftJavaScriptModel模型注入到JS中，在JS就可以通过WebViewJavascriptBridge调用我们暴露的方法了。context.setObject(model, forKeyedSubscript: "WebViewJavascriptBridge" as NSCopying &amp; NSObjectProtocol)// 注册到网络Html页面 请设置允许Http请求let curUrl = self.webView.request?.url?.absoluteString //WebView当前访问页面的链接 可动态注册context.evaluateScript(curUrl)context.exceptionHandler = &#123; (context, exception) inprint("exception：", exception as Any)&#125;&#125; Swift与JS方法互相调用 JS调用Swift方法12345WebViewJavascriptBridge.showDic(&#123;'title' : '字典传值，PierceDark 的博客','description' : '欢迎交流学习','url' : 'https://www.jianshu.com/u/50bd017bb4ba'&#125;) Swift调用JS方法并传参123456func callHandler(handleFuncName: String) &#123;let jsHandlerFunc = self.jsContext?.objectForKeyedSubscript("\(handleFuncName)")let dict = ["name": "sean", "age": 18]jsHandlerFunc?.callWithArguments([dict])&#125; 下载地址：Github：https://github.com/YunyueLin/SwiftJavaScriptCore。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift GCD 的一些高级用法]]></title>
    <url>%2F2017%2F10%2F13%2FSwift-GCD-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[信号量之前遇到一个问题，一个请求需要在另一个请求获得的参数。这个时候最开始的办法是把第二个请求写在第一个请求的回调里，但是这样的话，两个请求就很紧密的耦合在一起了。这个时候可以使用信号量来使他们分离开来。先看下相关的3个方法： dispatch_semaphore_t dispatch_semaphore_create(long value)：方法接收一个long类型的参数, 返回一个dispatch_semaphore_t类型的信号量，值为传入的参数long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)：接收一个信号和时间值，若信号的信号量为0，则会阻塞当前线程，直到信号量大于0或者经过输入的时间值；若信号量大于0，则会使信号量减1并返回，程序继续住下执行long dispatch_semaphore_signal(dispatch_semaphore_t dsema)：使信号量加1并返回 下面看几种使用方法保持线程同步123456789let semaphore = DispatchSemaphore.init(value: 0)var i = 10DispatchQueue.global().async &#123;i = 100semaphore.signal()&#125;semaphore.wait()print("i = \(i)") 输出i ＝ 100如果注掉semaphore.wait()这一行，则 i ＝ 10注释： 由于是将block异步添加到一个并行队列里面，所以程序在主线程跃过block直接到semaphore.wait()这一行，因为semaphore信号量为0，所以当前线程会一直阻塞，直到block在子线程执行到semaphore.signal()，使信号量+1，此时semaphore信号量为1了，所以程序继续往下执行。这就保证了线程间同步了。 为线程加锁(同时可以控制最大并发数量 , value 的值等于几就是最多几个并发)123456789let semaphore = DispatchSemaphore.init(value: 1)for i in 0..&lt;100 &#123;DispatchQueue.global().async &#123;semaphore.wait()print("i = \(i)")semaphore.signal()&#125;&#125; 注释：当线程1执行到semaphore.wait()这一行时，semaphore的信号量为1，所以使信号量-1变为0，并且线程1继续往下执行；如果当在线程1的print这一行代码还没执行完的时候，又有线程2来访问，执行semaphore.wait()时由于此时信号量为0(.wait()方法默认时间是 OC 的DISPATCH_TIME_FOREVER)，所以会一直阻塞线程2（此时线程2处于等待状态），直到线程1执行完print并执行完semaphore.signal()使信号量为1后，线程2才能解除阻塞继续住下执行。以上可以保证同时只有一个线程执行print这一行代码。 栅栏函数(barrier)等待异步执行多个任务后, 再执行下一个任务，一般使用barrier函数12345678910111213141516171819202122232425262728293031323334//创建串行队列// let queue = DispatchQueue.init(label: "test", qos: .default, attributes: .init(rawValue: 0), autoreleaseFrequency: .workItem, target: nil)//创建并行队列let queue = DispatchQueue.init(label: "test", qos: .default, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil)queue.async &#123;//任务一for _ in 0...3 &#123;print("......")&#125;&#125;queue.async &#123;//任务二for _ in 0...3 &#123;print("++++++");&#125;&#125;queue.async(group: nil, qos: .default, flags: .barrier) &#123;print("group")&#125;queue.async &#123;print("finish")&#125;最后打印......++++++++++++++++++++++++..................groupfinish 注释:使用barrier函数可以做到先让前面的任务执行完毕，再执行之后的任务，会阻塞当前的线程 延时任务123456789101112131415161718let queue = DispatchQueue.init(label: "test", qos: .default, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil)queue.async &#123;//任务一for _ in 0...3 &#123;print("......")&#125;&#125;print("0")queue.asyncAfter(deadline: DispatchTime.now() + 10, execute: &#123;print("延时提交的任务")&#125;)queue.async &#123;//任务二for _ in 0...3 &#123;print("++++++");&#125;&#125;打印： _注释_：10s后提交。并且不会阻碍当前线程 组的用法(Group)notify(依赖任务)1234567891011121314151617181920212223242526272829303132333435363738let queue = DispatchQueue.init(label: "test", qos: .default, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil)let group = DispatchGroup()queue.async(group: group, qos: .default, flags: [], execute: &#123;for _ in 0...10 &#123;print("耗时任务1")&#125;&#125;)queue.async(group: group, qos: .default, flags: [], execute: &#123;for _ in 0...10 &#123;print("耗时任务2")&#125;&#125;)//执行完上面的两个耗时操作, 回到myQueue队列中执行下一步的任务group.notify(queue: queue) &#123;print("回到该队列中执行")&#125;queue.async &#123;print("完成")&#125;打印：耗时任务2完成耗时任务1耗时任务2耗时任务2耗时任务2耗时任务2耗时任务1耗时任务2耗时任务1耗时任务1耗时任务1耗时任务1回到该队列中执行 注释：使用group+notify的话，也会等待之前的任务先执行完，和barrier的区别是不会阻碍当前的线程 wait(等待任务)1234567891011121314151617181920212223242526272829303132333435363738394041let queue = DispatchQueue.init(label: "test", qos: .default, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil)let group = DispatchGroup()queue.async(group: group, qos: .default, flags: [], execute: &#123;for _ in 0...5 &#123;print("耗时任务1")&#125;&#125;)queue.async(group: group, qos: .default, flags: [], execute: &#123;for _ in 0...5 &#123;print("耗时任务2")&#125;&#125;)//等待上面任务执行，会阻塞当前线程，超时就执行下面的，上面的继续执行。可以无限等待 .distantFuturelet result = group.wait(timeout: .now() + 2.0)switch result &#123;case .success:print("不超时, 上面的两个任务都执行完")case .timedOut:print("超时了, 上面的任务还没执行完执行这了")&#125;print("接下来的操作")打印：耗时任务1耗时任务2耗时任务1耗时任务2耗时任务1耗时任务2耗时任务1耗时任务2耗时任务1耗时任务2耗时任务1耗时任务2不超时, 上面的两个任务都执行完接下来的操作 注释:使用wait+group的话，如果设置timeout = .distantFuture的话，那么就和barrier函数一样了，会等待之前的完成，否则就是等待之前的完成或者等待设置的时间到了，就会执行接下来的任务了，会阻塞当前现场。 参考:iOS GCD之dispatch_semaphore学习 来自萌小菜 Swift 3.0 GCD的常用方法 来自床前明月_光]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz 2D 在 Swift 中的应用]]></title>
    <url>%2F2017%2F09%2F26%2FQuartz-2D-%E5%9C%A8-Swift-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Quartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统。其实 iOS 中很多控件都是通过 Quartz 2D 画出来的.同时Quartz 2D还可以做这些事情,12341、剪裁图形2、涂鸦/画板（如签名等）3、手势解锁(连线)4、折线图、饼状图、柱形图等绘制(虽然我都是直接用 charts) 使用 Quartz 2D绘图的核心步骤：1234561、获得上下文2、绘制/拼接绘图路径3、将路径添加到上下文4、渲染上下文记住：所有的绘图，都是这个步骤，即使使用贝塞尔路径，也只是对这个步骤进行了封装。对于绘图而言，拿到上下文很关键。 其中图形上下文有五种 12345Bitmap Graphics ContextPDF Graphics ContextWindow Graphics ContextLayer Graphics ContextPrinter Graphics Context 使用Quartz 2D自定义 UI 控件绘图的方法12345671.新建一个类，继承自UIView2.必须实现- (void)drawRect:(CGRect)rect方法，然后在这个方法中，可以：取得跟当前view相关联的图形上下文绘制相应的图形内容，绘制时产生的线条称为路径。 路径由一个或多个直线段或曲线段组成。利用图形上下文将绘制的所有内容渲染显示到view上面也可以：利用UIKit封装的绘图函数直接绘图 关于drawRect:123456789101112为什么要实现drawRect:方法才能绘图到view上？因为在drawRect:方法中才能取得跟view相关联的图形上下文drawRect:方法在什么时候被调用？当view第一次显示到屏幕上时（被加到UIWindow上显示出来）调用view的setNeedsDisplay或者setNeedsDisplayInRect:时在drawRect:方法中取得上下文后，就可以绘制东西到view上View内部有个layer（图层）属性，drawRect:方法中取得的是一个Layer Graphics Context，因此，绘制的东西其实是绘制到view的layer上去了View之所以能显示东西，完全是因为它内部的layer 12345678910111213141516171819//一些常用方法//获取上下文对象let context = UIGraphicsGetCurrentContext()//线条颜色context?.setStrokeColor(UIColor.red.cgColor)//线条宽度context?.setLineWidth(1.0)//移动画笔到某一点context?.move(to: CGPoint(x: 10, y: 10))//画线context?.addLine(to: CGPoint(x: gameSize , y: 10))//画弧线 （方法1 ，这个方法如果画一个完整的圆的话，//有起始点的时候，只会连接起始点和重点，不会出现圆的轨迹!）context?.addArc(center: CGPoint.init(x: 150, y: 100), radius: 30, startAngle: 0, endAngle: CGFloat(M_PI*2), clockwise: true); 1context?.addArc(center: CGPoint.init(x: 150, y: 100), radius: 30, startAngle: 0, endAngle: CGFloat(M_PI), clockwise: true); 123456789101112131415161718192021222324252627//画圆弧 （方法2）context?.addArc(tangent1End: CGPoint(x: 50, y: 50), tangent2End: CGPoint(x: 100, y: 50), radius: 50)//二次贝塞尔曲线context?.addQuadCurve(to: CGPoint.init(x: 150, y: 150), control: CGPoint.init(x: 50, y: 100))//三次贝塞尔曲线context?.addCurve(to: CGPoint.init(x: 250, y: 150), control1: CGPoint.init(x: 50, y: 100), control2: CGPoint.init(x: 100, y: 150))//设置填充颜色context?.setFillColor(UIColor.brown.cgColor);//绘制矩形context?.fill(CGRect.init(x: 50, y: 50, width: 100, height: 50));//绘制椭圆context?.strokeEllipse(in: CGRect.init(x: 50, y: 50, width: 100, height: 50));//旋转context?.rotate(by: CGFloat.pi * 0.3)//如果是需要使用矩阵变换(如平移，缩放，旋转等)，需要把添加路径放到后面//也就是需要把路径添加进加入上下文之前进行,context?.addArc(center: CGPoint(x: 50, y: 50), radius: 50, startAngle: 0, endAngle: CGFloat.pi, clockwise: true)//绘制context?.drawPath(using: .stroke) 上下文栈1234561.入栈context?.saveGState()2.出栈context?.restoreGState()3.如果出战的次数大于入栈，就会奔溃4.什么是入栈？就是拷贝当前图形上下文，然后放到栈中， 只使用一个CGContextRef的话，需要很多修改上下文属性（颜色，线宽等）的重复代码，所以可以保存当前上下文属性进入栈中5.如何理解拷贝图形上下文，我们操作的图形上下文成为A,此时如果图形上下文就设置了context?.setStrokeColor(UIColor.green.cgColor)这一个属性，入栈（我们把拷贝后入栈的成为B），然后我们继续操作当前上下文(现在称为 B)，但是我们出栈 A， 当前上下文的样式都是只有一个context?.setStrokeColor(UIColor.green.cgColor)的状态！说白了，就是保存某种图形上下文的状态！5.出栈的上下文，将样式赋值给当前样式，然后释放 出栈入栈参考自 王鑫20111 的https://www.jianshu.com/p/604b386d0468]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 类的构造方法]]></title>
    <url>%2F2017%2F09%2F13%2FSwift-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇文章讲解了在 Swift 中的类的构造规则。 Swift 类或结构体如果所有的属性都有默认值，同时没有自定义构造器，那么 Swift 会给这些结构体或类提供一个默认构造器，它后简单的创建一个所有属性值都设置为默认值的实例。12345class Test &#123;var title = "Test"&#125;Test() 类的继承和构造过程:类里面的所有存储型属性(包括所有继承自父类的属性），都必须在构造器中设置默认值。类类型有两种构造器来保证所有存储型属性都获得默认值，他们是指定构造器和便利构造器。 Swift 采用以下三条规则来限制构造器之间的代理调用:1234567规则 1 指定构造器必须调用其直接父类的的指定构造器。规则 2 便利构造器必须调用同类中定义的其它构造器。规则 3 便利构造器必须最终导致一个指定构造器被调用。一个更方便记忆的方法是:• 指定构造器必须总是向上代理 • 便利构造器必须总是横向代理 如图所示： 两段式构造过程：Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存 储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。 Swift 编译器执行 4 种有效的安全检查。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647安全检查 1 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中 的构造器。安全检查 2 指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的 新值将被父类中的构造器所覆盖。安全检查 3 便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予 的新值将被同一类中其它指定构造器所覆盖。安全检查 4 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个 值。//对于 1-3class SuperClass &#123;var title : Stringinit() &#123;title = &quot;title&quot;&#125;&#125;class SomeClass: SuperClass &#123;var content : String//重写父类的指定构造器override init() &#123;//先初始化自己的属性content = &quot;testContent&quot;super.init()//再初始化继承来的属性title = &quot;subClass title&quot;&#125;//便利convenience init(content:String)&#123;self.init()//先调用指定构造器，再修改属性self.content = content&#125;&#125;//对于4 刚好回答了很久之前一个点击按钮不走方法的坑var testBtn = &#123; () -&gt; UIButton inlet testBtn = UIButton()//这样不行，因为在执行 Block 的时候，self 还没有初始化完成， 如果需要在这里写，可以用懒加载的方式testBtn.addTarget(self, action: #selector(someMethod), for: .touchUpInside)return testBtn&#125;() 以下是构造流程展示12345678910阶段 1• 某个指定构造器或便利构造器被调用。• 完成新实例内存的分配，但此时内存还没有被初始化。• 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。• 指定构造器将调用父类的构造器，完成父类属性的初始化。• 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。• 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完 全初始化。此时阶段 1 完成。阶段 2• 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问 self 、修改它的属性并调用实例方法等等。• 最终，任意构造器链中的便利构造器可以有机会定制实例和使用 self 。 构造器的继承和重写: 跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止 一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。12345678父类的构造器仅会在 你为子类中引入的所有新属性都提供了默认值 情况下被继承。规则 1 如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。规则 2如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将 自动继承所有父类的便利构造器。即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。 这里有个好玩的事情，子类可以把父类的指定构造器重写为便利构造器 123456789101112131415161718192021222324252627在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器:class Car &#123;var name: Stringinit(name: String) &#123;self.name = name&#125;convenience init() &#123;self.init(name: "[Unnamed]")&#125;&#125;class Audi: Car &#123;var displacement: Intinit(name: String, displacement: Int) &#123;self. displacement = displacementsuper.init(name: name)&#125;override convenience init(name: String) &#123;self.init(name: name, displacement: 1)&#125;&#125;其中 Audi 的便利构造器 ‘override convenience init(name: String)’ 使用了和 Car 中的指定构造器‘init(name: String)’相同的参数，所以这个便利构造器实际是重写了父类的指定构造器。而且尽管 Audi 将父类的指定构造器重写为便利构造器，它依然提供了父类的所有指定构造器的实现，所以 Audi 还有自动继承父类的所有便利构造器 必要构造器: 123456789101112class SomeClass &#123;required init() &#123;// 构造器的实现代码&#125; &#125;在子类重写父类的必要构造器时，必须在子类的构造器前也添加 required 修饰符，表明该构造器要求也应用于继 承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 override 修饰符:class SomeSubclass: SomeClass &#123;required init() &#123;// 构造器的实现代码 &#125;&#125; PS：开始使用 Swift都一年多时间了，觉得开始好好整理整理博客了，毕竟写出来比只是自己学有更好的学习效果，还能当个笔记。先从简单的基础开始 ，然后再慢慢写别的东西。欢迎大家交流哦~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
</search>
